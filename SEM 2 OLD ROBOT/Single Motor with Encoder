#define NUM_MOTORS 4
#define ENC_COUNT_REV 216
const int in13[] = {5, 2, 14, 26}; // Define the direction pin for Motor Driver
const int in24[] = {4, 15, 13, 27}; // Define the direction pin for Motor Driver
const int enca[] = {18, 19, 32, 35};
const int encb[] = {22, 23, 25, 33};
// pwm channels
const int PWM_CHANNELS[] = {0, 1, 2, 3};
const int PWM_FREQ = 5000;
const int PWM_RESOLUTION = 8;
const int MAX_DUTY_CYCLE = pow(2, PWM_RESOLUTION) - 1;
volatile int encoderValues[NUM_MOTORS] = {0}; // Make sure to declare as volatile if used in interrupt
// interrupt variables mainly encoder
volatile int pos_i[]          = {0};             // get position from interrupt 
volatile int currT_i[]        = {0};        // store current time from micros()
volatile long prevT_i[]       = {0};       // store previous time from micros()
volatile float deltaT_i[]     = {0};     // store change in time between signals
volatile float velocity2_i[]  = {0};  // store calculated velocity 2 (in count/s)
float v1[] = {0}; //
float v2[] = {0};
// Low Pass Filter variable array of 2 element which will represent the speed of left and right side of the vehicle 
volatile float v1Filt[] = {0}; 
volatile float v1Prev[] = {0};
volatile float v2Filt[] = {0};
volatile float v2Prev[] = {0};
int currentStateA;
int lastStateA;
int counter=0;
int increment = 0;
void IRAM_ATTR handleEncoderInterrupt() {
  
}

void setup() {
  Serial.begin(9600);
  for (int i = 0; i < NUM_MOTORS; i++) {
    pinMode(enca[i], INPUT);
    pinMode(encb[i], INPUT);
    attachInterrupt(digitalPinToInterrupt(enca[i]), handleEncoderInterrupt, RISING); // triggered first when wheel spins clockwise
    attachInterrupt(digitalPinToInterrupt(encb[i]), handleEncoderInterrupt, RISING); // triggered first when wheel spins anti-clockwise
    ledcSetup(PWM_CHANNELS[i], PWM_FREQ, PWM_RESOLUTION);
    ledcWrite(PWM_CHANNELS[i], 0); // write to zero initially
  }
  // setup in1,2 motor driver pins
  ledcAttachPin(in13[0], PWM_CHANNELS[1]);
  ledcAttachPin(in24[0], PWM_CHANNELS[0]);
  ledcAttachPin(in13[1], PWM_CHANNELS[1]);
  ledcAttachPin(in24[1], PWM_CHANNELS[0]);
  ledcAttachPin(in13[2], PWM_CHANNELS[3]);
  ledcAttachPin(in24[2], PWM_CHANNELS[2]);
  ledcAttachPin(in13[3], PWM_CHANNELS[3]);
  ledcAttachPin(in24[3], PWM_CHANNELS[2]);

  // Read the initial state of A
  lastStateA = digitalRead(enca[1]);
}
int pwmVal = 1.0 * 255;
int pwmVal2 = 0.0 * 255;
void loop() {
  // send PWM signal to motor driver
  ledcWrite(PWM_CHANNELS[2], pwmVal2);
  ledcWrite(PWM_CHANNELS[3], pwmVal);
  ledcWrite(PWM_CHANNELS[0], pwmVal2);
  ledcWrite(PWM_CHANNELS[1], pwmVal);
  // read the current state of pin A
  currentStateA = digitalRead(enca[1]);
  // If last and current state of A are different, then pulse occurred
  // React to only 1 state change to avoid double count
  if(lastStateA != currentStateA && currentStateA == 1){
    
    // If the encoder pin B state is different than pin A state, then the encoder is rotating 
    // CCW so decrement
    if(digitalRead(encb[1]) != currentStateA){
      counter++;
      increment = 1;
      
      //Serial.println("CW");
      //Serial.println(counter);
    } else {
      // Encoder is rotating CW so increment
      counter--;
      increment = -1;
      //Serial.println("CCW");
      //Serial.println(counter);
    
    }
    long currTj = micros(); // get the current time 
    deltaT_i[0] = ((float) (currTj - prevT_i[0]))/1.0e6; // store the time between each signals
    //Serial.print("deltaT: ");
    //Serial.println(deltaT_i[0]); 
    
    velocity2_i[0] = (increment*60.0)/(deltaT_i[0]*210.0); // velocity in RPM
    // Low-pass Filter (40 Hz Cutoff Pretty Good) <- Like Really need to change
    v1Filt[0] = 0.843*v1Filt[0] + 0.0782*(velocity2_i[0]) + 0.0782*v1Prev[0];
    v1Prev[0] = velocity2_i[0]; 
    prevT_i[0] = currTj;
    
    // convert counts/s to RPM
    //Serial.print("velocity: ");
    Serial.println(v1Filt[0]);
    //Serial.println("RPM");
    
  }
  // Remember last pin A state
  lastStateA = currentStateA;
    
  
 /* int increment_i = 0; 
  int b = digitalRead(encb[1]); // read encb 
  if(b>0) {
    increment_i = 1; // indicate forward
    
  }
  else {
    increment_i = -1; // indicate reverse
  }
  pos_i[0] += increment_i; 
  
  long currTj = micros(); // get the current time 
  deltaT_i[0] = ((float) (currTj - prevT_i[0]))/1.0e6; // store the time between each signals 
  velocity2_i[0] = increment_i/deltaT_i[0]; // velocity 
  
  
  prevT_i[0] = currTj; */
  //Serial.println(counter);
  //Serial.print("Velocity: ");
  //Serial.println(velocity2_i[0]);
  
  delay(1);
}

